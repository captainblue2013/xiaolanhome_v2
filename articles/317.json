{
  "id": 317,
  "title": "three.js 学习之自转的地球",
  "keywords": [
    "three.js",
    "webgl"
  ],
  "content": "<p>首先需要知道什么是 three.js。 简单的说，three.js 是一个非常优秀的 WebGL 开源框架, three(3d) + js(javaScript)。其开源项目的地址：</p>\n\n<blockquote>\n<p>github: https://github.com/mrdoob/three.js</p>\n</blockquote>\n\n<p>而 WebGL 是在浏览器中实现三维效果的一套规范。</p>\n\n<p>在 three.js 中有几大重要的概念需要先了解一下：</p>\n\n<ul>\n<li>场景（scene）</li>\n<li>相机（camera）</li>\n<li>渲染器（renderer）</li>\n</ul>\n\n<p><strong>关键</strong>：有了这三样东西，我们才能够使用相机将场景渲染到网页上去`</p>\n\n<h4 id=\"toc_0\">1、scene</h4>\n\n<p>在 WebGL 世界里，场景是一个非常重要的概念，它是存放所有物体的容器。在 three.js 里面新建一个场景很简单，new THREE.Scene 实例就好了。代码如下：</p>\n\n<blockquote>\n<p>var scene = new THREE.Scene();  // 场景只有一种</p>\n</blockquote>\n\n<h4 id=\"toc_1\">2、camera</h4>\n\n<ul>\n<li>相机（camera）</li>\n</ul>\n\n<blockquote>\n<p>var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000) ;</p>\n</blockquote>\n\n<p><code>PerspectiveCamera( fov, aspect, near, far )</code></p>\n\n<ul>\n<li>fov(Number): 仰角的角度</li>\n<li>aspect(Number): 截平面长宽比，多为画布的长宽比。</li>\n<li>near(Number): 近面的距离</li>\n<li>far(Number): 远面的距离</li>\n</ul>\n\n<p>图解 THREE.PerspectiveCamera 参数，如下:\n<img src=\"https://tse3-mm.cn.bing.net/th?id=OIP.3Jjn7ZAyk9IZUQWgLklF2AHaDn&amp;w=300&amp;h=300&amp;p=0&amp;o=5&amp;pid=1.7\" alt=\"\"></p>\n\n<h4 id=\"toc_2\">3、renderer</h4>\n\n<p>渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制。</p>\n\n<div><pre><code class=\"language-none\"> var renderer = new THREE.WebGLRenderer();\n renderer.setSize(window.innerWidth, window.innerHeight);\n document.body.appendChild(renderer.domElement);</code></pre></div>\n\n<p>好了，几大概念简单的说了，还不是很明白也不打紧，先看下最终的效果：</p>\n\n<p><img src=\"http://bluestest.oss-cn-shanghai.aliyuncs.com/earth.gif\" alt=\"\"></p>\n\n<h4 id=\"toc_3\">开始画地球</h4>\n\n<p>1、导入 <code>three.min.js</code> 文件，可以下载到本地，也可以采用 cdn, 我这里采用的是下载下来的方式：</p>\n\n<blockquote>\n<p>&lt;script src=&quot;assets/plus/threejs/three.min.js&quot;&gt;&lt;/script&gt;</p>\n</blockquote>\n\n<p>或者</p>\n\n<blockquote>\n<p>&lt;script src=&quot;https://cdn.bootcss.com/three.js/r83/three.min.js&quot;&gt;&lt;/script&gt;</p>\n</blockquote>\n\n<p>2、准备渲染器 renderer 的 domElement 元素</p>\n\n<blockquote>\n<p>&lt;div id=&quot;canvas-frame&quot;&gt;&lt;/div&gt;</p>\n</blockquote>\n\n<p><code>&lt;style&gt;&lt;/style&gt;</code> 中加入 css:</p>\n\n<div><pre><code class=\"language-none\"> div#canvas-frame {\n     border: none;\n     cursor: pointer;\n     width: 100%;\n     height: 100vh;\n     background-color: #EEEEEE;\n}</code></pre></div>\n\n<p>3、实例化一个 scence 对象, 用来存放我们的地球实体。</p>\n\n<div><pre><code class=\"language-none\">// 场景\nvar scene;\nfunction initScene() {\n   scene = new THREE.Scene();\n}</code></pre></div>\n\n<p>4、准备搭建 camera 的位置，和调节角度,在 three.js 里面采用给的是<code>右手坐标系</code>：</p>\n\n<div><pre><code class=\"language-none\">// 相机\nvar camera;\nfunction initCamera() {\n   camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);\n   camera.position.x = -500;\n   camera.position.y = 500;\n   camera.position.z = -500;\n}</code></pre></div>\n\n<p>这里采用的是透视相机。 视角越大，看到的场景越大，那么中间的物体相对于整个场景来说，就越小了。</p>\n\n<p>5、准备渲染器 renderer</p>\n\n<div><pre><code class=\"language-none\">// 渲染器\nvar renderer;\nfunction initThree() {\n   width = document.getElementById(&#39;canvas-frame&#39;).clientWidth;\n   height = document.getElementById(&#39;canvas-frame&#39;).clientHeight;\n   // 实例化 THREE.WebGLRenderer 对象。\n   renderer = new THREE.WebGLRenderer({\n                        antialias: true,\n                        alpha: true,\n                        canvas: renderer\n                      });\n   // 设置 renderer 的大小\n   renderer.setSize(width, height);\n   // 挂载到准备的 domElement 上\n   document.getElementById(&#39;canvas-frame&#39;).appendChild(renderer.domElement); \n   // Sets the clear color and opacity.\n   renderer.setClearColor(0x000000, 1.0);\n}</code></pre></div>\n\n<p>这里对 THREE.WebGLRenderer 实例的参数进行讲解。</p>\n\n<ul>\n<li><code>canvas</code> - 渲染器绘制输出的那个 canvas, 这对应于下面的 domElement 属性。如果没有在设置，则会创建一个新的画布元素。</li>\n<li><code>antialias</code> - 抗锯齿化</li>\n<li><code>alpha</code> - alpha 缓冲区</li>\n</ul>\n\n<p>6、画地球啦，这里的地球其实就是在一个球体上贴上带有地球纹路的贴纸。</p>\n\n<div><pre><code class=\"language-none\">// 地球\nvar earthMesh;\nfunction initEarth() {\n    // 实例化一个半径为 200 的球体\n   var earthGeo = new THREE.SphereGeometry(200, 100, 100);\n   var earthMater = new THREE.MeshPhongMaterial({\n            map: new THREE.TextureLoader().load(&#39;./assets/earth.jpg&#39;)\n        });\n   earthMesh = new THREE.Mesh(earthGeo, earthMater);\n   scene.add(earthMesh);\n}</code></pre></div>\n\n<p>7、给地球加上云层；</p>\n\n<div><pre><code class=\"language-none\">// 云\nvar cloudsMesh;\nfunction initClouds() {\n\n    // 实例化一个球体，半径要比地球的大一点，从而实现云飘咋地球上的感觉\n    var cloudsGeo = new THREE.SphereGeometry(201, 100, 100);\n    \n    // transparent 与 opacity 搭配使用，设置材质的透明度，当 transparent 设为 true 时， 会对材质特殊处理，对性能会有些损耗。\n    var cloudsMater = new THREE.MeshPhongMaterial({\n        alphaMap: new THREE.TextureLoader().load(&#39;./assets/clouds.jpg&#39;),\n        transparent: true,\n        opacity: 0.2\n    });\n    \n    cloudsMesh = new THREE.Mesh(cloudsGeo, cloudsMater);\n    scene.add(cloudsMesh);\n}</code></pre></div>\n\n<p>到这里地球就画完了，但是，就像现实的世界一样，如果你不给它打点光，世界就是漆黑一片的，所以接下来给我们的 scene 加点光吧。</p>\n\n<p>8、给世界来点光，世界还你一片彩。</p>\n\n<div><pre><code class=\"language-none\">// 光源\nvar light;\nfunction initLight() {\n    // A light source positioned directly above the scene, with color fading from the sky color to the ground color. \n    // 位于场景正上方的光源，颜色从天空颜色渐变为地面颜色。\n    //  var light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);\n    // scene.add(light);\n    \n    // 环境光\n    light = new THREE.AmbientLight(0xFFFFFF);\n    light.position.set(100, 100, 200);\n    scene.add(light);\n    \n    // 平行光\n    // 位置不同，方向光作用于物体的面也不同，看到的物体各个面的颜色也不一样\n    // light = new THREE.DirectionalLight(0xffffbb, 1);\n    // light.position.set(-1, 1, 1);\n    // scene.add(light);\n}</code></pre></div>\n\n<p>这里采用的是环境光，其它注释了的两种光的效果也不错哦~\n直到这里，地球就画出来了，但是我们的题目是画一颗自转的地球，那我们如何让它自己转起来呢？我们继续往下看。</p>\n\n<p>9、引入一个控制器，这里如果你足够厉害自己写也可以哦，我采用的开源的。</p>\n\n<div><pre><code class=\"language-none\"> &lt;script src=&quot;assets/plus/threejs/js/controls/OrbitControls.js&quot;&gt;&lt;/script&gt;</code></pre></div>\n\n<div><pre><code class=\"language-none\"> // 载入控制器\n var controls = new THREE.OrbitControls(camera, renderer.domElement);</code></pre></div>\n\n<p>10、定义地球和云层自转的动画，速度不一样会更像哦。这里说说为什么循环动画使用的是 <code>requestAnimationFrame</code>, 而不是更熟知的 <code>setInterval</code>？<code>setInterval</code> 是到点就往任务队列里插，是 JS 引擎的定时器方法；<code>requestAnimationFrame</code> 是跟着浏览器的绘制走，浏览器每次重绘的时候调用，是 DOM 引擎提供的方法。</p>\n\n<div><pre><code class=\"language-none\">function animate() {\n  controls.update();\n  // 地球自转\n  earthMesh.rotation.y -= 0.002;\n  // 漂浮的云层\n  cloudsMesh.rotation.y -= 0.005;\n  cloudsMesh.rotation.z += 0.005;\n  renderer.render(scene, camera);\n  requestAnimationFrame(animate);\n}</code></pre></div>\n\n<p>自转的地球到这里就大功告成啦~</p>\n\n<p>完整的代码见：https://github.com/jiangyuzhen/three-earth</p>\n\n<div><pre><code class=\"language-none\">Tips: 有的小伙伴克隆上面的代码后， 用双击 index.html 的方式看不到效果，可以自己搭一个静态服务或者试试 anywhere (随启随用的静态文件服务器)：</code></pre></div>\n\n<p>步骤如下:</p>\n\n<div><pre><code class=\"language-none\">// 全局安装\nnpm i anywhere -g \n\n// 文件根目录下执行\nanywhere</code></pre></div>\n\n<h4 id=\"toc_4\">相关资料</h4>\n\n<ul>\n<li>https://threejs.org/</li>\n<li>https://github.com/omni360/three.js.sourcecode</li>\n<li>http://www.hewebgl.com/article/articledir/3</li>\n</ul>",
  "createdAt": 1523943839,
  "modified": 1523943839
}