{
  "id": "180",
  "title": "jquery 新建的元素事件绑定问题 ",
  "keywords": [
    "jquery"
  ],
  "content": "<p>  js的事件监听跟css不一样，css只要设定好了样式，不论是原来就有的还是新添加的，都有一样的表现。而事件监听不是，你必须给每一个元素单独绑定事件。</p>\n\n<p>常见的例子是处理表格的时候。每行行末有个删除按钮，点了这个能够删除这一行。</p>\n\n<pre><code>&lt;table&gt;\n    &lt;tbody&gt;\n        &lt;tr&gt;\n            &lt;td&gt;这行原来就有&lt;/td&gt;\n            &lt;td&gt;&lt;buttonclass=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;这行原来就有&lt;/td&gt;\n            &lt;td&gt;&lt;buttonclass=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;</code></pre>\n\n<p>通常，我会这么绑定</p>\n\n<pre><code>jQuery(function($){\n    //已有删除按钮初始化绑定删除事件\n    $(&quot;.del&quot;).click(function() {\n    $(this).parents(&quot;tr&quot;).remove();\n    });\n});</code></pre>\n\n<p>对于在domready之前就存在的删除按钮，一切都很完美。但如果在domready之后用js动态添加几行，那新增的几行中的这些按钮都将失去任何作用。</p>\n\n<p>如何解决这个问题？以下提供4种解决方案：</p>\n\n<p>0号解决方案——onclick法\n如果不顾结构与行为分离的准则的话，通常，我会这么做。\n注意，此时的deltr这个function必须是全局函数，得放jQuery(function($) {})外面，放里边就成局部函数了，html里的onclick就调用不到了！</p>\n\n<pre><code>&lt;td&gt;&lt;buttononclick=&quot;deltr(this)&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;\n\n    jQuery(function($){\n    //添加行\n        $(&quot;#add2&quot;).click(function(){\n        $(&quot;#table2&gt;tbody&quot;).append(&#39;&lt;tr&gt;&lt;td&gt;新增行&lt;/td&gt;&lt;td&gt;&lt;button nclick=&quot;deltr(this)&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;&#39;)\n        });\n    });\n//删除行的函数，必须要放domready函数外面\nfunction deltr(delbtn){\n    $(delbtn).parents(&quot;tr&quot;).remove();\n};</code></pre>\n\n<p>1号解决方案——重复绑定法\n即，在domready的时候就给已有的元素绑定事件处理函数，\n而后当新增加的元素的时候再次绑定。</p>\n\n<pre><code>&lt;td&gt;&lt;buttonclass=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;\njQuery(function($){\n//定义删除按钮事件绑定\n//写里边，防止污染全局命名空间\nfunction deltr(){\n    $(this).parents(&quot;tr&quot;).remove();\n};\n//已有删除按钮初始化绑定删除事件\n$(&quot;#table3 .del&quot;).click(deltr);\n//添加行\n$(&quot;#add3&quot;).click(function(){\n    $(&#39;&lt;tr&gt;&lt;td&gt;新增行&lt;/td&gt;&lt;td&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;&#39;)\n    .find(&quot;.del&quot;).click(deltr).end()\n    .appendTo($(&quot;#table3&gt;tbody&quot;));\n});\n});</code></pre>\n\n<p>2号解决方案——事件冒泡法\n利用事件冒泡的原理，我们给这个按钮的祖先元素绑定事件处理函数。\n然后通过event.target这个对象来判断，这个事件是不是我们要找的对象触发的。\n通常可以利用一些DOM属性，比如event.target.className、event.target.tagName等之类的来判断。</p>\n\n<pre><code>&lt;td&gt;&lt;buttonclass=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;\n\njQuery(function($){\n    //第四个表格的删除按钮事件绑定\n    $(&quot;#table4&quot;).click(function(e) {\n        if (e.target.className==&quot;del&quot;){\n            $(e.target).parents(&quot;tr&quot;).remove();\n        };\n    });\n    //第四个表格的添加按钮事件绑定\n    $(&quot;#add4&quot;).click(function(){\n        $(&quot;#table4&gt;tbody&quot;).append(&#39;&lt;tr&gt;&lt;td&gt;新增行&lt;/td&gt;&lt;td&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;&#39;)\n    });\n});</code></pre>\n\n<p>3号解决方案——复制事件法\n上面几种方案可以说即便你没有用到jQuery库，你也能相对比较容易的实现。但这种方案相对依赖jQuery的程度更高。而且必须要求jQuery 1.2版以上。低版本jQuery需要插件。\n上面两个方案都是对删除函数动了很多脑筋，换了多种触发、绑定的方式。这个方案不同，可以与平时纯静态的元素一样在domready的时候绑定。但在我们添加新行的时候我们改动一下，不再想上面那样拼接字符串来添加新行了。这回我们尝试使用复制DOM元素的方式。并且复制的时候连同绑定的事件一起复制，复制完之后再用find之类的修改内部的元素。\n同时，就像这个例子，如果你会把所有元素都删除光，那template这个模板是必须的，如果不会删光，那就未必需要用template了。为了防止被误删，此处我把template设了隐藏。\n我使用了jQuery中特有的clone(true)</p>\n\n<pre><code>1..template{display:none;}\n\n1.&lt;trclass=&quot;template&quot;&gt;\n2.           &lt;td&gt;这里是模板&lt;/td&gt;\n3.           &lt;td&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;\n4.       &lt;/tr&gt;\n5.       &lt;tr&gt;\n6.           &lt;td&gt;这行原来就有&lt;/td&gt;\n7.           &lt;td&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;\n8.       &lt;/tr&gt;\n9.       &lt;tr&gt;\n10.           &lt;td&gt;这行原来就有&lt;/td&gt;\n11.           &lt;td&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;\n12.       &lt;/tr&gt;\n\n1.jQuery(function($){\n2.   //第五个表格的删除按钮事件绑定\n3.    $(&quot;#table5 .del&quot;).click(function() {\n4.        $(this).parents(&quot;tr&quot;).remove();\n5.   });\n6.   //第五个表格的添加按钮事件绑定\n7.    $(&quot;#add5&quot;).click(function(){\n8.        $(&quot;#table5&gt;tbody&gt;tr:eq(0)&quot;)\n9.           //连同事件一起复制\n10.            .clone(true)\n11.           //去除模板标记\n12.            .removeClass(&quot;template&quot;)\n13.           //修改内部元素\n14.            .find(&quot;td:eq(0)&quot;)\n15.                .text(&quot;新增行&quot;)\n16.                .end()\n17.           //插入表格\n18.            .appendTo($(&quot;#table5&gt;tbody&quot;))\n19.   });\n20.});</code></pre>\n\n<p>复制代码</p>\n\n<p>总评：\n上面4种方案，各有优劣。\n0号方案，结构与行为完全没有分离，而且污染全局命名空间。最不推荐。所以我都不把它当作一个方案来看。但对于js初学者，可以用来项目救急。\n1号方案，中规中矩，没啥好也没啥不好\n2号方案，这种方法充分的发挥了js事件冒泡的优势。而且效率最高。但同时由于这种方案无视了jQuery强大的选择器，所以如果涉及的元素属性要求过多就会比较麻烦了。你会徘徊在众多if的条件的是非关系之中。后来我想起来，可以用jQuery中的$(event.target).is(selector)来作为条件。这样可以极大提升开发效率，但略微降低执行效率。\n3号方案，这是我认为最能体现结构与行为分离的思想的一种方案。但缺点也很明显，对于jQuery依赖性过于高了，要不就自己写一个复制连同事件一起复制的函数，但这也显然对于初学者来说异常困难。但从未来的趋势的角度来看，还是很推荐使用这种方案的。</p>\n\n<p>具体选用哪一个方案，没有定数。具体看你的项目以及你js还有结构与行为分离的思想的掌握程度。最适合的才是最好的。</p>",
  "createdAt": 1414117740,
  "modified": 1415951877
}