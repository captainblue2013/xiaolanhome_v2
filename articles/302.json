{
  "id": "302",
  "title": "致杨先生,关于《javascript到底是如何运行的》",
  "keywords": [
    "javascript",
    "js",
    "node"
  ],
  "content": "<h3>致杨先生：</h3>\n\n<h4>前言</h4>\n\n<blockquote><p>引用 <a href=\"http://xiaomingplus.com/full-stack/how-to-run-for-javascript/\">javascript到底是如何运行的？--杨先生</a></p></blockquote>\n\n<p>当我们讨论<code>javascript</code>运行机制这种问题，有别于语法，语法我们有标准可以参考，对于运行机制，我们应该明确是什么引擎。</p>\n\n<p>在这我以V8为例，猜想杨先生大概也是V8，从node源码的角度，补充一二。\n行文没有顺序，只是针对一些观点的补充。</p>\n\n<h4>正文</h4>\n\n<hr/>\n\n<blockquote><p>在js中，有多种类型的观察者，包括文件I/O观察者,网络请求观察者等（其实这里的观察者一般来讲就是宿主环境提供的API）</p></blockquote>\n\n<p>观察者其实不是什么API，而是一种结构。</p>\n\n<p>举个例子，如果是网络IO观察者，它的结构是这样的：</p>\n\n<pre><code>{\n\tfd,\n\tcallback\n}</code></pre>\n\n<p>这个是<code>uv__io_s </code>类型的对象，而我们常说的<code>事件循环</code>里的一个个单元，就是这样的对象。</p>\n\n<p>而文件IO观察者，想必也是差不多，待我进一步研读源码再来求证。</p>\n\n<hr/>\n\n<blockquote><p>一个JavaScript运行时包含一个待处理的任务队列，该队列是先进先出的，队列里的每一个任务都与一个函数相关联（一般是调用API时指定的回调函数）。当[执行栈]为空时，[执行栈]会从[任务队列]中取出队列里最前面的一个任务进行处理。</p></blockquote>\n\n<p>任务队列一直一个值得我们深刻研究的话题，在杨先生的描述里，js有一个“执行栈”，一个任务队列。执行栈 先执行一次，然后从队列里取出一个，如此往复，直到结束。</p>\n\n<p>某个程度上可以这么描述，不过对于杨先生的水平，我认为是要有更高的要求的，这里面，有很多不太严谨的地方。</p>\n\n<p>我将从几个问题来展开：</p>\n\n<p><strong>1.什么是任务队列？</strong></p>\n\n<p>任务队列是 <code>default_loop_struct</code>，来自结构体定义 <code>uv_loop_s</code>。正如前面所说，里面存放的是观察者。</p>\n\n<p><strong>2.什么是  <code>Tick</code></strong></p>\n\n<p>我们知道有一个 <code>process.nextTick</code> 方法，但是 <code>Tick</code> 到底是什么，要从任务队列的运行机制去了解。</p>\n\n<p><code>default_loop_struct</code> 里面的观察者是以链表的结构存储的。而 <code>Tick</code> 里是以 数组 的方式存储的。</p>\n\n<p>杨先生之前的描述只是 执行栈 与 <code>Tick</code> 之间的交互，实际上，每次取出一个任务，都是从<code>Tick</code>里取的。而<code>Tick</code>其实是 <code>default_loop_struct</code>的全量镜像。</p>\n\n<blockquote><p>注：是不是全量，我还需要继续考证，在此仅供参考。</p></blockquote>\n\n<p>所以真正的关系链是:</p>\n\n<pre><code>main() &lt;---  Tick  &lt;--- default_loop_struct</code></pre>\n\n<p>在这里顺便说一下，<code>process.nextTick</code> 会让一个callback加到<code>Tick</code>里，而其他的 timer 之类（setTimeout，setImmediate），只会加到 <code>default_loop_struct </code> 。此中区别，还需细细品味。</p>\n\n<p><strong>3.任务队列的时机</strong></p>\n\n<p>在杨先生文中的那个图，我不能说它是错的，但是并没有表达出一个关键信息，就是执行轨迹。</p>\n\n<p>真实的情况是 <code>main()</code>执行完所有JS代码后,进入<code>uv_run()</code>，再去看看 <code>default_loop_struct </code>有没有观察者，没有则程序结束，如果有，则进入<code>epoll_wait()</code>。</p>\n\n<p>以上不理解没关系，可以日后细细研究，在此我只想表达一点，JS不会一边执行代码一边跟任务队列做互动。不信你可以试试，连续一堆 <code>setTimeout </code>,然后直接<code>process.exit()</code>，那么还没来得及进入<code>uv_run()</code>，程序就结束了，这些任务自然一个都执行不了。</p>\n\n<h4>其他</h4>\n\n<p>以上还有一些用语不太严谨，不过为了行文连贯，做出一定的牺牲，需要考究准确性的地方，我们还需要私下讨论为佳。</p>",
  "createdAt": 1475820357,
  "modified": 1475820357
}