{
  "id": 321,
  "title": "一种支持插件式开发的命令行工具开发模式",
  "keywords": [
    "node",
    "command line"
  ],
  "content": "<h4>0x00 前言</h4>\n\n<p>我想你一定没有真正通顺地读一遍本文的标题。</p>\n\n<p>是的，这不重要。</p>\n\n<p>大概只是扫了一眼，抓取到 <strong>插件</strong>、<strong>命令行</strong> 这样的关键字，所以你点开了这个链接。</p>\n\n<p>不过我相信你一定是一个命令行开发的狂热分子，又或者只是对命令行开发有一点点感兴趣。</p>\n\n<p>无论如何，我非常建议你花几分钟阅读完这一篇，然后我们可以通过其他的方式，继续讨论命令行开发的话题。</p>\n\n<p><img alt=\"\" src=\"https://raw.githubusercontent.com/mohism-framework/cli-wrapper/master/assets/7.png\"/></p>\n\n<h4>0x01 故事的起因: 我开发了太多的命令行工具</h4>\n\n<p>一开始只是因为懒（社会进步的动力），把一组经常要执行的命令，用<code>Node</code>开发成一个工具。</p>\n\n<p>得益于<code>Node</code>出色的编程能力，以及丰富的<code>file system</code> API，它非常有效地把我们从繁琐的重复工作中解放出来。</p>\n\n<blockquote><p>在处理重复工作这件事上，计算机比人类可靠得多。 —— —— 某先哲</p></blockquote>\n\n<p>于是我们陷入了魔怔。</p>\n\n<p> 我们为本地开发流程规范开发了命令行工具。</p>\n\n<p> 我们为 <strong>持续集成/发布</strong> 过程开发了命令行工具。</p>\n\n<p> 我们为容器集群管理开发了命令行工具。</p>\n\n<p> 我们为我们见到的一切，开发了命令行工具。</p>\n\n<h5>渐渐地我们发现事情变得糟糕起来。</h5>\n\n<blockquote><p>命令行工具让我们从重复工作里解放出来，却让我们陷入了重复的命令行开发当中。 —— —— 某先哲</p></blockquote>\n\n<p><img alt=\"\" src=\"https://raw.githubusercontent.com/mohism-framework/cli-wrapper/master/assets/8.png\"/></p>\n\n<h4>0x10 插件，命令行需要插件</h4>\n\n<p>功劳最大的是 James， 他为我们准备了咖啡和小甜点，于是我们总结出目前的困境：</p>\n\n<ul><li>你不可避免地开发好几个独立的命令行工具</li></ul>\n\n<pre><code>\t如果我们把上面的几个工具集成到一起，那么它将变得非常臃肿。\n\t而且把一些不相干的命令全部放在一起，绝对不是个好主意。</code></pre>\n\n<ul><li>我只想专注于我的命令在做什么，而不是一些重复的东西</li></ul>\n\n<pre><code>\t我们每开发一个新的工具，不得不做一些重复的内容，以便它看起来像一个完整的工具。\n\t因为我们要求它只管且漂亮。\n\t比如帮助信息、用例、格式化输出、参数定义、显示版本、升级。。。\n\t总之就是很多。</code></pre>\n\n<ul><li><p>我很喜欢你做的这个功能，但是只能复制你的代码，这样看起来很蠢</p><pre><code>不仅如此。\n有时候，我甚至希望自己做出来这个功能，可以方便地分享给其他成员。</code></pre></li></ul>\n\n<p>几乎没有任何分歧，我们认为接下来我们要做这样一个东西，它要实现这些特点：</p>\n\n<ol><li>一个非常出色地完成<strong>帮助信息、用例、格式化输出、参数定义、显示版本</strong>等重复工作的命令行工具脚手架</li><li>一个只关注命令行为逻辑的开发约定（你只需要写你的功能代码，而不是那些啰嗦的环节）</li><li>命令必须是可以共享、替换、组合、进化的插件单元</li></ol>\n\n<blockquote><p>平凡与伟大之间的距离，有时只是一杯咖啡。 —— —— 某先哲</p></blockquote>\n\n<p><img alt=\"\" src=\"https://raw.githubusercontent.com/mohism-framework/cli-wrapper/master/assets/9.png\"/></p>\n\n<h3>0x11 正文开始：现在你可以使用一下 <code>@mohism/cli-wrapper</code></h3>\n\n<p>如果你现在就去浏览 <a href=\"https://github.com/mohism-framework/cli-wrapper\">cli-wrapper文档</a> ， 并顺利开发出一个命令行工具，那这将是一个很好的开始。</p>\n\n<p>因为对于 <code>cli-wrapper</code> 的定义：</p>\n\n<ul><li><p>首先它是一个脚手架，快速生成一个基础功能完善的项目，然后只写一点点你的创意</p><p><code>cli-wrapper</code>默默地为开发者提供了一系列我们过去开发命令行中被认为是<strong>good part</strong>的部分。开发者无需去<s>学习怎样引导命令</s>、<s>怎样使用鲜明的输出信息</s>、<s>怎样存储本地文件</s>、<s>怎样去接收交互参数</s>。</p><p>你需要的仅仅是，弄清楚你要做的功能，然后写下为数不多的代码</p></li><li><p>其次，<code>cli-wrapper</code>开发的命令，都可以发布为插件</p><p>这是一个令人兴奋的设计，我们之前的工具里有一些功能，是应该被共享到其他更多的工具里的，\n比如 <code>升级本程序</code>、<code>问题反馈</code>。（截止到目前，你已经可以在npm上看到 <a href=\"https://www.npmjs.com/package/@mohism/self-upgrade\">升级本程序</a> ）</p><p>而现在这一切变成现实。</p><p>更可怕的是，我们把所有的命令都分别发布为插件，然后像乐高积木一样，任意组合出我们需要的命令行工具。</p></li></ul>\n\n<p><img alt=\"\" src=\"https://raw.githubusercontent.com/mohism-framework/cli-wrapper/master/assets/10.png\"/></p>\n\n<h4>0x0д(overflow) 最后的最后</h4>\n\n<p>上面只是介绍了 <code>cli-wrapper</code> 这个项目的起源和一些粗浅的特性。</p>\n\n<p>如果你是一个命令行开发爱好者，我强烈建议你</p>\n\n<ol><li>移步 <a href=\"https://github.com/mohism-framework/cli-wrapper\">cli-wrapper文档</a> 并尝试开发出一个命令行工具</li><li>向 <a href=\"https://github.com/mohism-framework/cli-wrapper/issues\">这个地方</a>提出你宝贵的建议</li><li>或者直接联系我们，交流一下命令行的开发心得。</li></ol>\n\n<p><img alt=\"\" src=\"https://raw.githubusercontent.com/mohism-framework/cli-wrapper/master/assets/11.png\"/></p>",
  "createdAt": 1571852077,
  "modified": 1571852077
}