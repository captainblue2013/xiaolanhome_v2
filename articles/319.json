{
  "id": 319,
  "title": "使用 WaitGroup 做并发控制",
  "keywords": [
    "go",
    "golang",
    "waitgroup"
  ],
  "content": "<h4>0x00 题目：一个常见的业务场景</h4>\n\n<blockquote><p>通过气象台提供的天气接口，<strong>并行</strong>地获取<code>北京</code>和<code>成都</code>的天气情况，返回一个无序列表。</p><p>接口参考: <code>http://www.weather.com.cn/data/cityinfo/{城市编码}.html</code></p><p>北京 101010100    成都  101270101</p></blockquote>\n\n<p>以上业务场景，属于比较常见的并行获取资源。</p>\n\n<p>多进程（线程）（协程）并行操作是基本操作，考核点在于如何让主线可以统筹控制各个支线。</p>\n\n<p>一般来说我们有3种常见结题思路：</p>\n\n<ol><li>全局共享的哨兵变量</li><li>利用<code>channel</code>做协程间的通信（模型类似事件监听）</li><li>通过高度封装的 <code>sync.WaitGroup</code></li></ol>\n\n<p>由于后续会专门出一篇关于<code>channel</code>的内容，本篇我们只讲述最简单的<code>sync.WaitGroup</code></p>\n\n<h5>=============== 敲黑板分界线 ================</h5>\n\n<blockquote><p>此处只展示结构，完整代码请看 <a href=\"https://github.com/captainblue2013/pieces-of-code\">这里</a></p></blockquote>\n\n<pre><code>package main\n\nimport (\n\t&quot;encoding/json&quot;\n\t&quot;fmt&quot;\n\t&quot;io/ioutil&quot;\n\t&quot;net/http&quot;\n\t&quot;sync&quot;\n)\n\n/**\n *\n */\ntype WeatherBody struct {\n\tWeatherInfo `json:&quot;weatherinfo&quot;`\n}\n\ntype WeatherInfo struct {\n\t// 城市\n\tCity string `json:&quot;city&quot;`\n\t// 最低温度\n\tLow string `json:&quot;temp1&quot;`\n\t// 最高温度\n\tHigh string `json:&quot;temp2&quot;`\n}\n\n// 获取天气情况的函数\nfunc GetWeatherByCity(cityCode string) WeatherInfo {\n\tresp, err := http.Get(&quot;http://www.weather.com.cn/data/cityinfo/&quot; + cityCode + &quot;.html&quot;)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(resp.Body)\n\tweatherBody := WeatherBody{}\n\n\tjson.Unmarshal(body, &amp;weatherBody)\n\n\treturn weatherBody.WeatherInfo\n}\n\nfunc main() {\n\tresult := []WeatherInfo{}\n\t// 声明一个 waitGroup 并增加两个等待信号\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\t// 使用协程请求北京天气情况\n\tgo func() {\n\t\tweatherInfo := GetWeatherByCity(&quot;101010100&quot;)\n\t\tresult = append(result, weatherInfo)\n\t\t// 告诉 wg 我已经完成任务\n\t\twg.Done()\n\t}()\n\n\t// 使用协程请求成都天气情况\n\tgo func() {\n\t\tweatherInfo := GetWeatherByCity(&quot;101270101&quot;)\n\t\tresult = append(result, weatherInfo)\n\t\t// 告诉 wg 我已经完成任务\n\t\twg.Done()\n\t}()\n\n\twg.Wait()\n\tfmt.Printf(&quot;%+v\\n&quot;, result)\n}\n\n/**\n知识点\n1. http模块的使用方式\n2. byte数组与 json 的转换\n3. WaitGroup 的 Add、Done、Wait方法的配合使用\n*/</code></pre>\n\n<h5>主要代码讲解</h5>\n\n<ol><li>通过 <code>wg.Add(2)</code>设置两个信号量</li><li>在 <code>goroutine</code> 里执行任务结束后，记得调用<code>wg.Done()</code></li><li>在 <strong>主协程</strong> 里使用 <code>wg.Wait()</code>等待所有任务完成</li><li>打印结果</li></ol>\n\n<h4>0x01 提问 &amp; 练手 环节</h4>\n\n<ol><li>上述代码，如果把 <code>wg.Add(2)</code> 改为 <code>wg.Add(1)</code> 会是什么效果？</li><li>上述代码，如果把 <code>wg.Add(2)</code> 改为 <code>wg.Add(3)</code> 会是什么效果？</li><li>上述代码，如果去掉 <code>wg.Wait()</code>会是什么效果？</li></ol>",
  "createdAt": 1559548981,
  "modified": 1559548981
}