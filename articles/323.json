{
  "id": 323,
  "title": "命令行开发 - 提醒与自动补全实践",
  "keywords": [
    "命令行"
  ],
  "content": "<h3>0x00 命令行工具的自动补全</h3>\n\n<p>开发一个命令行工具不难，完善命令行工具的周边设施，才是迈向专业命令行开发的关键。</p>\n\n<p>而今天提到的 <strong>命令行自动补全</strong>，就是命令行工具提升体验的重中之重。</p>\n\n<p>比如，当我们输入 <code>git</code> 并按下键盘上的 <code>tab</code>，我们会得到多达 <strong>131</strong>条的命令提醒。</p>\n\n<p><img src=\"https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/1.png\" style=\"width:80%;margin:0 10%;\"/></p>\n\n<p>这当然对我们使用毫无帮助，但是如果我们输入 <code>git che</code> 并按下 <code>tab</code>，我们就能得到一个十分愉悦的反馈。</p>\n\n<p><img src=\"https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/2019112000.gif\" style=\"width:80%;height:auto;margin:0 10%;\" /></p>\n\n<h3>0x01 命令开发好了，却总是忘记怎么用</h3>\n\n<p>这一节，我们从一个已经开发号的命令入手，一步一步实现自动补全。</p>\n\n<p><img src=\"https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/2019112001.gif\" style=\"width:80%;height:auto;margin:0 10%;\" /></p>\n\n<p>正如我们看到的，这个临时开发出来的<code>hello</code>命令，并不具备自动补全。</p>\n\n<p>我们期望当输入完<code>hello</code>并按下<code>tab</code>，可以得到提醒并快速地选择<code>chengdu</code><code>freeCodeCamp</code><code>mohism</code>中的一个。</p>\n\n<p>同时，我们期望当我们输入<code>hello c</code>并按下<code>tab</code>，无需更多的选择，<code>chengdu</code> 会被自动选择，并且填充到输入的末尾。</p>\n\n<h3>0x10 如何让命令拥有自动补全的功能</h3>\n\n<blockquote><p>开始之前，提示一下<br>\n1. 下面动图里关于闪烁以及突然补全，都是因为我按了 <code>tab</code><br>\n2. 下面列出来的所有 shell 脚本，默认都是保存到一个文件里，并且在恰当的时候执行<code>source</code>让它生效<br>\n3. 希望你看得懂第2条</p></blockquote>\n\n<p>实现自动补全的原理并不复杂，只需要系统内置的 <code>complete</code>命令即可。</p>\n\n<p>我们不妨先手动试试，在命令行输入</p>\n\n<blockquote><p> complete -W \"chengdu freeCodeCamp mohism\" hello</p></blockquote>\n\n<p>简单讲解一下上面的命令，<code>-W</code> 参数，指的是使用文本（字符串）来做补全方式，多个单词使用空格分开。</p>\n\n<p>意思就是，输入<code>hello</code>以后，可以通过<code>tab</code>来提醒并选择<code>chengdu freeCodeCamp mohism</code>中的一个。</p>\n\n<p>如果我们把上面命令加入到我们的 <code>.bashrc</code>里，那每一次打开 SHELL 都能享受到<code>hello</code>命令的自动提醒了。</p>\n\n<p><strong>咦？这么简单就完成了吗？？</strong></p>\n\n<p>当然不是的，请看</p>\n\n<p><img src=\"https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/2019112002.gif\" style=\"width:80%;height:auto;margin:0 10%;\" /></p>\n\n<p>显然这并不能让我们满意，因为 <code>-W</code>参数只能实现一些简单的功能，更多的情况下，我们会使用 <code>-F</code>，为自动补全指定<strong>函数</strong>。</p>\n\n<p>先奉上完整版：</p>\n\n<pre><code>hello_completions()\n{\n  #有点长，拖动查看\n  if [[ \"${COMP_CWORD}\" == \"1\" ]];then\n    COMPREPLY=($(compgen -W \"chengdu freeCodeCamp mohism\" \"${COMP_WORDS[1]}\"))\n  fi\n}\n\ncomplete -F hello_completions hello</code></pre>\n\n<p>上面这个知识点就有点多了，大家可以反复读一下以下五点：</p>\n\n<ol><li><code>-F</code>的使用，一目了然不需要叙述；</li><li><code>COMPREPLY</code>，这个补全函数内置的，我们需要给它赋值为一个数组，\n\t这里需要一点点 shell 编程能力。<code>COMPREPLY</code>数组最后的元素，就是我们按下<code>tab</code>\t后会提示的内容。</li><li><code>compgen</code>是另一个内置命令，<code>compgen -W \"abc abd ccc\" a</code> 的意思，就是从<code>\n\tabc abd ccc</code>里过滤<code>a</code>开头的元素，得到<code>abc abd</code>。</li><li><code>COMP_WORDS</code>是另一个内置变量，它记录了你此时输入的内容。这个比较抽象，当你输入\t<code>hello che</code>时，<code>COMP_WORDS[0]</code>就是<code>hello</code>，<code>COMP_WORDS[1]</code>就是<code>che</code>。</li><li>还有开头的 <code>COMP_CWORD </code>，指的是我们正在输入的第几个词。结合第4条，当我们正在\t输入第 <code>1</code>个词（<code>hello</code>是第<code>0</code>个），才会执行补全逻辑。</li></ol>\n\n<p>加起来，这个函数的意思就是</p>\n\n<blockquote><p>我们获取到输入<code>hello</code>之后（排除空格）的第一个输入，比如<code>ch</code>, 然后前缀匹配<code>chengdu freeCodeCamp mohism</code>，过滤后得到的结果（如 <strong>ch</strong>engdu）,</p><p>作为自动补全的选项(<code>COMPREPLY</code>)。</p></blockquote>\n\n<p>well ? 看起来跟一开始的没什么不一样。我们再看看效果：</p>\n\n<p><img src=\"https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/2019112003.gif\" style=\"width:80%;height:auto;margin:0 10%;\" /></p>\n\n<p>细心的朋友就会发现，我们通过 <code>if [[ \"${COMP_CWORD}\" == \"1\" ]]</code>来解决了上面出现过的 <strong>无限提醒补全问题</strong>。</p>\n\n<p>OK，到这里一个基本的自动补全实现方式，就算完成了。更多细节的用法，我还是推荐各位自行搜索更多的资料，加强学习。</p>\n\n<h3>0x11 深入：二阶段命令补全</h3>\n\n<p>故事当然还没结束，好事者给这个<code>hello</code>命令增加了一些功能</p>\n\n<p><img src=\"https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/2.png\" style=\"width:80%;margin:0 10%;\"/></p>\n\n<p>显然，我们被要求对子命令的参数做进一步的提醒与补全。</p>\n\n<p><strong>那就开干吧</strong></p>\n\n<pre><code>hello_completions()\n {\n    if [[ \"${COMP_CWORD}\" == \"1\" ]];then\n      COMPREPLY=($(compgen -W \"chengdu freeCodeCamp mohism\" ${COMP_WORDS[1]}))\n    elif [[ \"${COMP_WORDS[1]}\" == \"mohism\" ]];then\n      COMPREPLY=($(compgen -W \"--color -t\" $(t=${COMP_WORDS[${COMP_CWORD}]} &amp;&amp; echo ${t//-/})))\n    fi\n  }\n\n  complete -F _hello_completions hello</code></pre>\n\n<p>原来事情并没有那么复杂，我们只需要再判断第<code>1</code>个输入（<code>COMP_WORDS[1]</code>）为 <code>mohism </code>时，重新定义 <code>COMPREPLY</code>数组的元素即可。</p>\n\n<blockquote><p>tips: 上面没有讲解的 <code>$(t=${COMP_WORDS[${COMP_CWORD}]} &amp;&amp; echo ${t//-/})</code> <br>\n就讲给爱学习的人自己去了解吧，把它当作学习 shell 编程的好机会。</p></blockquote>\n\n<p>此时我们看看完整效果：</p>\n\n<p><img src=\"https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/2019112004.gif\" style=\"width:80%;height:auto;margin:0 10%;\" /></p>\n\n<h3>0xFF 开箱即用的 @mohism/cli-wrapper</h3>\n\n<p>冷不防一个广告。</p>\n\n<p>本人开发的   <strong>用来快速开发命令行工具的工具</strong>  （拗口？）</p>\n\n<p><a href=\"https://github.com/mohism-framework/cli-wrapper\"><img src=\"https://camo.githubusercontent.com/5199dcf53f33f6e8c4bc5c4d8d074ccd8d7ec884/68747470733a2f2f302e67726176617461722e636f6d2f6176617461722f66326632666464646436663162393833666236346535626438313930393235363f643d68747470732533412532462532466769746875622e6769746875626173736574732e636f6d253246696d6167657325324667726176617461727325324667726176617461722d757365722d3432302e706e6726723d6726733d3430\" style=\"width:18px;line-height:18px;\"/> @mohism/cli-wrapper</a></p>\n\n<p>除了能够非常方便快捷地用 <code>Nodejs</code>开发命令行工具外，它还能帮你<strong>自动生成</strong>支持命令补全的脚本。</p>\n\n<p>所以，如果我们通过 <code>@mohism/cli-wrapper</code>来开发这个 <code>hello</code>命令的话。。。。</p>\n\n<p><img src=\"https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/2019112005.gif\" style=\"width:80%;height:auto;margin:0 10%;\" /></p>\n\n<p>谢谢阅读。</p>",
  "createdAt": 1574267617,
  "modified": 1574267617
}