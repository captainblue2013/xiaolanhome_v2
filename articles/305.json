{
  "id": "305",
  "title": "记一次结构化数据的经历",
  "keywords": [
    "结构化",
    "schema"
  ],
  "content": "<h4>0.背景</h4>\n\n<p>故事的背景，是源于要为第三方提供一套接口，而这套接口又是依赖于其他内部数据API。</p>\n\n<p>这看起来好像有点平常，不过事情通常没有想象中那么顺利。</p>\n\n<p>这问题在于，内部的API接口，正在处于一个动荡的年代，结构说变就变。有时候可能只是属性名变了，有时候甚至整块数据都不见了。</p>\n\n<p>而对于一套给第三方用的接口，这是致命的。我们需要保持数据模型的绝对稳定性。</p>\n\n<p><img alt=\"\" src=\"http://www.lanhao.name/img/upload/fake_api.png\"/></p>\n\n<h4>1.有哪些需要做的？</h4>\n\n<p>从内部API拿到数据，剔除部分敏感信息，调整一下属性名，简化一下层次结构，这就是我们这套接口需要做的东西。</p>\n\n<p>以上的事情，都可以直接在代码里做的，反正简单<code>unset</code>一下，<code>array_*</code>一下，又不会太累，只要对照结构写就行。</p>\n\n<p><strong>但是开发者小蓝不会这么做!</strong></p>\n\n<p>这么做有以下不爽的地方：</p>\n\n<ul><li>底层API每次变动，都需要跟进编码，编码意味着可能出BUG</li><li>对于要产出的结构，没有一个明确的描述，只能靠代码</li><li>为了解决第二个问题，需要专门维护这个文档，告诉你产出是怎样的，时间长了，很容易“文(档)不对(代)码”</li></ul>\n\n<h4>2.应该怎么做</h4>\n\n<p>针对以上几个问题的思考，我希望能实现以下的指标：</p>\n\n<ul><li>最大限度地不受底层API的影响，即使底层有迭代，这边接口的输出结构稳定</li><li>依赖一些<code>Schema</code>文件来描述底层数据与输出数据之间的转化关系，以及直接能表达出输出数据的结构</li><li>有条件的情况下，还能根据<code>Schema</code>直接生产数据文档，保证文档与执行结果的统一性</li></ul>\n\n<p><strong>综上所述，我需要制定一个描述<code>Schema</code>的规范，以及编写一个数据转换的方法</strong></p>\n\n<h4>3.实际操作</h4>\n\n<p>我们先来放出一个源数据的例子</p>\n\n<pre><code>$source = [\n    &#39;arr&#39; =&gt; [\n        [\n            &#39;a&#39; =&gt; 1,\n            &#39;secret&#39;=&gt;&#39;hey&#39;\n        ],\n        [\n            &#39;a&#39; =&gt; 4,\n            &#39;secret&#39;=&gt;&#39;jude&#39;\n        ]\n    ],\n    &#39;hello&#39; =&gt; &#39;!&#39;\n];</code></pre>\n\n<p>首先是<code>Schema</code>部分，为了简单易用，目前直接使用编程语言内部的数据类型来描述。</p>\n\n<pre><code>$schema = [\n    &#39;arr=array&#39; =&gt; [\n        [\n            &#39;a=c&#39; =&gt; &#39;&#39;\n        ]\n    ]\n];</code></pre>\n\n<p> 这个<code>Schema</code>的含义就是：</p>\n\n<ul><li>首先<code>arr</code>这样的描述不清楚，要重命名为<code>array</code></li><li>其次，<code>array</code>是个数组，里面的元素的模型只展示一个<code>a</code>属性，并且重命名为<code>c</code></li><li><p><code>hello</code>这个属性，直接干掉</p><p>然后输出的结果就是：</p><pre><code>{\n    &quot;array&quot; : [\n        {\n            &#39;a&#39; : 1\n        },\n        {\n            &#39;a&#39; : 4\n        }\n    ]\n}</code></pre></li></ul>\n\n<p>当然，<code>Schema</code>规则肯定不止这两条，这里只挑比较直接的说明一下。</p>\n\n<p>同样的，规则可以慢慢添加，重要的是，整个体系的依托，要建立起来。</p>\n\n<p><strong>接下来就差一个转换函数了</strong></p>\n\n<p>代码就不贴了，无非就是根据<code>Schema</code>来读取<code>Source</code>的数据，</p>\n\n<p>遇到数组，就让<code>Source</code>循环起来，</p>\n\n<p>遇到对象,就让<code>Source</code>和<code>Schema</code>递归进去，</p>\n\n<p>对，递归是重点。</p>\n\n<p>写这个函数的过程就是，慢慢调bug，抓头发，拍大腿的过程，反正就是越来越健壮就是了。</p>\n\n<h4>4.立竿见影的好处</h4>\n\n<p>转换函数初步可用后，尝试着编写一个数据接口，包括编写<code>Schema</code>的时间，10分钟不到就出来了，还可靠。（按照对数据手写的话，估计半小时以上）</p>\n\n<p>而且写<code>Schema</code>的时候，可用将大脑切换到<strong>数据模式</strong>，一门心思地想数据，这样出错的可能也低许多。</p>\n\n<p>到运行稳定后甚至可以让其他人员来维护<code>Schema</code>，我们专心做其他技术细节。</p>",
  "createdAt": 1485174420,
  "modified": 1485176123
}