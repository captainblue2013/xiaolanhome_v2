{
  "id": "304",
  "title": "总结一些最近写Command Line Tool 的一些心得",
  "keywords": [
    "node",
    "命令行"
  ],
  "content": "<blockquote><p>总结一些最近写Command Line Tool 的一些心得</p></blockquote>\n\n<h2>yargs</h2>\n\n<pre><code>npm install yargs --save</code></pre>\n\n<p><code>yargs</code>是优雅地接受命令行输入参数的模块，功能非常强大且易用，免去了很多重复的工作，一段代码足以证明：</p>\n\n<pre><code>const argv = require(&#39;yargs&#39;).argv; \n\n// argv 会自动接受所有输入参数 ，比如 demo_command -a hello\n\nconsole.log(argv.a);  \n//hello</code></pre>\n\n<p>当然可以对 <code>a</code> 做更多的配置 </p>\n\n<pre><code>const yargs = require(&#39;yargs&#39;);\n\nlet argv = yargs.\n\t\toptions(&#39;a&#39;, {\n\t\t    alias: &#39;api&#39;,\n\t\t    default: &#39;all&#39;,\n\t\t  }).argv;\n//这样可以给 argv.a设置一个默认值，同时有一个别名，如：demo --api hello</code></pre>\n\n<p>更多的配置方式看<a href=\"https://github.com/yargs/yargs\">github</a></p>\n\n<hr/>\n\n<h2>colors</h2>\n\n<pre><code>npm install colors --save</code></pre>\n\n<p><code>colors</code>是用来控制命令行输出文本颜色的, 还有更多功能如 <code>背景色</code>、<code>字体特效</code> 等我用得比较少，需要学全的请看<a href=\"https://github.com/Marak/colors.js\">github</a>。</p>\n\n<pre><code>//用起来也是特别简单，\nconst colors = require(&#39;colors&#39;);\n\n//输出绿色的hello , 黄色的 world\nconsole.log(colors.green(&#39;hello &#39;) + colors.yellow(&#39;world&#39;));</code></pre>\n\n<p>更多预设颜色：black、red、green、yellow、blue、magenta、cyan、white、gray、grey</p>\n\n<p>主要是用于命令行输出提示信息，如红色的<code>error message</code></p>\n\n<hr/>\n\n<h2>readline-sync</h2>\n\n<pre><code>npm install readline-sync --save</code></pre>\n\n<p><code>readline-sync</code>是同步获取用户输入的模块，主要用于带交互的基本输入。</p>\n\n<p>常见的有询问用户是否同意 ，同意输入<code>yes</code>, 或者需要用户填写什么信息之类。</p>\n\n<pre><code>const readline = require(&#39;readline-sync&#39;);\n\nlet name = readline.question(&#39;What is your name? &#39;, {defaultInput: &#39;Tom&#39;});\n\nconsole.log(&#39;Oh! I got it! You are &#39;+name);</code></pre>\n\n<p>输出：</p>\n\n<pre><code>$ node test.js \nWhat is your name? Gay  \nOh! I got it! You are Gay</code></pre>\n\n<p><code>readline-sync</code>的功能远远不止这样，还有很多交互方式，详情看<a href=\"https://github.com/anseki/readline-sync\">github</a></p>\n\n<hr/>\n\n<h2>关于目录的一些问题</h2>\n\n<h4>HOME</h4>\n\n<p><code>HOME</code>目录在Command Line 中也比较常用，可以让你生成一些本地文件，或者配置文件。\n<code>Linux</code> 和 <code>OSX</code>中，可以通过环境变量来获取。</p>\n\n<pre><code>process.env[&#39;HOME&#39;];\n//  当前用户的目录</code></pre>\n\n<p>而<code>windows</code>的话，我就没研究了。</p>\n\n<h4>命令所在的源码目录</h4>\n\n<pre><code>__dirname\n\n当前执行的脚本的目录，不管你在哪个目录下调用，这个返回的都是源码所在目录</code></pre>\n\n<p>这个指的是你当前命令的执行文件源码的目录（或理解为 <code>安装目录</code>）。</p>\n\n<p>它的作用是，你可能需要从你开发的命令的源码里加载一些文件，或者模板。</p>\n\n<p>比如 一些框架的脚手架 ，需要生产代码 ，自然就是从脚手架的目录里copy一份模板。</p>\n\n<h4>当前目录</h4>\n\n<pre><code>process.cwd()</code></pre>\n\n<p>这个是指你输入命令的当前目录。</p>\n\n<p><strong>要活用以上两个目录，在写 Command Line Tool 的时候会经常用到。</strong></p>\n\n<h3>注意 EOL 的坑</h3>\n\n<pre><code>require(&#39;os&#39;).EOL</code></pre>\n\n<p>这是一个很方便的功能，它会抹平操作系统的差异性，返回一个换行符。\n在你打印信息的时候十分常用。</p>\n\n<p><strong>不过注意有一个坑</strong></p>\n\n<p>如果你需要生产一些文本文件，那你需要特别注意里面用的换行符。</p>\n\n<p>比如我在<code>linux</code>下生成的配置文件，弄到 <code>windows</code>下就解释不出来了。</p>",
  "createdAt": 1484897520,
  "modified": 1512093781
}