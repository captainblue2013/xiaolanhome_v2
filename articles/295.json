{
  "id": "295",
  "title": "yield方式的异步代码什么原理？（刨根向）",
  "keywords": [
    "generator",
    "yield",
    "promise"
  ],
  "content": "<blockquote><p>江湖上流传着一个说法，说是通过 yield 和 generator ，就是用同步的方式写出异步的代码。</p><p>真的是这样吗？</p><p>也许你可以从网上搜到很多相关教程，照着样例代码，你也能写出这样的代码。但是你是否真的已经明白，这背后到底发生了什么？</p></blockquote>\n\n<h3>第一集，他是谁？</h3>\n\n<p>这就是一个 <code>generator</code>，</p>\n\n<pre><code>var gen = function* (){\n\treturn 1;\n}</code></pre>\n\n<p>看上去像个函数，浑身有一种莫名其妙的的罪恶感，对了，他让我想起那恶心的指针。</p>\n\n<p>我们看看运行起来会怎么样？</p>\n\n<pre><code>gen();\n// {}</code></pre>\n\n<p>看来只是长得像，跟函数没啥关系呢。</p>\n\n<p>我想他还有其他不为人知的地方，比如，<code>next()</code></p>\n\n<pre><code>var a = gen();\nconsole.log( a.next() );\n\n// { value: 1, done: true }   duang！！</code></pre>\n\n<p>我明白了，要调用<code>next</code>才能让他执行起来。</p>\n\n<h3>第二集，yield ？</h3>\n\n<p>如果 <code>generator</code> 遇上 <code>yield</code> 会怎样？</p>\n\n<pre><code>var gen = function* (){\n\tyield 2;\n\treturn 1;\n}\nvar a = gen();\nconsole.log( a.next() );\n// { value: 2, done: false }</code></pre>\n\n<p>他并没有返回1，而是2 ，一个被 <code>yield</code>了的2 。</p>\n\n<p>那么这个<code>done</code>的值，应该就是告诉我还没执行完的意思吧。</p>\n\n<p>那我能不能多<code>next</code>几次？</p>\n\n<pre><code>var a = gen();\nconsole.log( a.next() );\n// { value: 2, done: false }\nconsole.log( a.next() );\n// { value: 1, done: true }\nconsole.log( a.next() );\n// { value: undefined, done: true }</code></pre>\n\n<p>果然，只要<code>done</code>没返回 <code>true</code> 就可以一直 <code>next</code>下去。（注：<code>false</code>也可以继续<code>next</code>，不过已经没有什么意义了 ）</p>\n\n<p><strong>一个典型的迭代器呼之欲出 ！</strong></p>\n\n<p>没错，<code>generstor</code>就是一个迭代器,暂时来说和异步编程没有任何关系</p>\n\n<pre><code>var item = null;\nwhile( item = a.next() ){\n\tif(item.done === true){\n\t\tbreak;\n\t}\n\t// do anything with {item}\n\tconsole.log(item.value);\n}\n\n// 2 , 1</code></pre>\n\n<h3>第三集，Promise  和 CO</h3>\n\n<p><code>generator</code>的诞生就是为了成为一个伟大的迭代器，阴差阳错之下，被用来写异步代码。\n这得从他遇上 <code>promise</code> 说起。</p>\n\n<p><strong><code>generator</code>，或者说 <code>yield</code>有一个很特别的能力——移花接木。</strong></p>\n\n<p><img alt=\"\" src=\"http://lanhao.name/img/upload/yield1.png\"/></p>\n\n<p>一个 <code>yield</code> 表达式包含很丰富的操作，一行代码包含了两个阶段逻辑</p>\n\n<ul><li>执行最右边的操作 <code>2+3</code> ，把结果通过<code>value</code>带出去。（<code>next</code> 的返回值）</li><li>再次调用<code>next</code>时，可以接受参数，将外面的值传进来，赋值给 <code>a</code></li></ul>\n\n<p><strong>君子无罪，怀璧其罪</strong></p>\n\n<p>这种特异功能被眼尖的程序员发现了，一个伟大的设想诞生了。</p>\n\n<ul><li>先将异步操作用<code>promise</code>实现，通过<code>yield</code>带出去</li><li>然后执行<code>then</code>函数，获取异步处理结果</li><li>再次执行<code>next</code>，将异步结果传回 <code>generator</code>内部，赋值给<code>yield</code>左边的表达式</li></ul>\n\n<p><img alt=\"\" src=\"http://lanhao.name/img/upload/yield2.png\"/></p>\n\n<p><strong>如此一来，这一行代码看起来就像同步代码一样！</strong></p>\n\n<p>我们看看成品代码：</p>\n\n<pre><code>var gen = function* () {\n  let content = yield httpGet(&#39;http://lanhao.name&#39;);\n  return content;\n};\n\nvar myCo = (fn) =&gt; {\n  let state = null;\n  let g = fn();\n  return (function next(data){\n\t state = g.next(data);\n\t if(state.done){\n\t  return state.value;\n\t }else{\n\t  return state.value.then( val =&gt; next(val) );\n\t }\n })();\n};\n\n\nvar a = myCo(gen);\n\na.then(val=&gt;console.log(val));\n\n//{&quot;code&quot;:200,&quot;data&quot;:[],&quot;message&quot;:&quot;&quot;}</code></pre>\n\n<p>而且我们发现，不管<code>generator</code>逻辑如何，<code>Co</code>的写法都是一样的，不会重复编码。</p>\n\n<p>只要通过<code>Co</code>来执行<code>generator</code>，我们就能像同步代码一样写异步操作。</p>\n\n<p><strong>以上就是 yield方式的异步代码 原理解释</strong></p>\n\n<p>（未完）</p>",
  "createdAt": 1467257644,
  "modified": 1467257644
}