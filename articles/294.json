{
  "id": "294",
  "title": "当我们说 Promise ，我们在说什么？（刨根向）",
  "keywords": [
    "promise",
    "javascript"
  ],
  "content": "<p>当我要组织文章内容的时候，我感到十分的吃力。</p>\n\n<p>这是源于一个困惑：我们现在是否还需要探讨什么是<code>Promise </code>？</p>\n\n<p>我们很容易就能 “使用” <code>Promise </code>，已经有很多优秀的模块实现了不同标准的<code>Promise </code>。\n而随着ES6原生 <code>Promise </code> 的落实，我们更容易写出 <code>Promise </code> 风格的异步代码。</p>\n\n<pre><code>// ES6 下的原生Promise\nvar httpGet = (url) =&gt; {\n  return new Promise( (resolved,rejected)=&gt;{\n    request.get(url,(err,res)=&gt;{\n      if(!err){\n        resolved(res);\n      }else{\n        rejected(err);\n      }\n    });\n  });\n}\n\nhttpGet(&#39;http://abc.com&#39;).then(...);</code></pre>\n\n<p>但是，治学这东西，知其然，还要知其所以然。</p>\n\n<p>尤其是现在很多声音还存在对 <code>Promise </code> 的曲解的情况下。</p>\n\n<h3>那么，Promise到底是什么东西？</h3>\n\n<p>有一种说法是用了<code>Promise </code>就不需要callback的写法了，实际上是不是这样，我们看一段代码</p>\n\n<pre><code>func(arg ,(err,ret)=&gt;{\n  //pass\n});\n\nfunc(arg).then( (err,ret)=&gt;{\n  //pass\n});</code></pre>\n\n<p>实际上只是callback写的位置不一样而已，并没有什么实际的改变。</p>\n\n<p><strong>是不是这样呢?我们层层深入地理解一下 Promise 到底是什么。</strong></p>\n\n<p>对于上面这个问题， <code>Promise </code> 是不是只是把callback换个地方写呢？</p>\n\n<p>我从《深入浅出Nodejs》 4.3.2 中的一段话收到了启发</p>\n\n<blockquote><p>上面的异步调用中，必须严谨地设置目标。那么是否有一种先执行异步调用，延迟传递处理的方式呢？</p></blockquote>\n\n<p>说的就是传统的callback写法，必须在异步调用的时候，明确地声明回调处理的逻辑。</p>\n\n<pre><code>httpGet(&#39;/api&#39;,{\n  success:onSuccess,\n  error:onError\n});</code></pre>\n\n<p>就是说，你必须明确指明了异步调用结束时的各种回调，然后才会执行异步操作</p>\n\n<pre><code>（声明异步操作）---&gt; (注册回调) ---&gt; (执行异步操作)</code></pre>\n\n<p>反过来看看 <code>Promise </code> 是不是就不一样呢？先看一段代码</p>\n\n<pre><code>var p = httpGet(&#39;/api&#39;);\n\np.then(onSuccess , onError);</code></pre>\n\n<p>你猜到底在哪一步发起了http请求？</p>\n\n<p>正如你猜测的一样，在 <code>p</code> 初始化的时候，这个异步操作就执行了。\n所以对于<code>Promise </code>来说，流程是这样的</p>\n\n<pre><code>（声明异步操作）---&gt; (执行异步操作) ---&gt; (注册回调)</code></pre>\n\n<p> &gt;原来真的存在一种方法，先执行异步调用，延迟传递处理的方式。这就是<code>Promise </code>与传统callback一个很显著的区别。</p>\n\n<h3>状态机</h3>\n\n<p>如果 <code>Promise </code> 只是对callback在逻辑顺序及书写方式上面的一点改动的话，</p>\n\n<p>那你就小看它了。</p>\n\n<p>有没有想过，为什么 <code>Promise </code> 能先执行异步操作，再指明回调逻辑呢？下面这段代码又会如何？</p>\n\n<pre><code>var p = httpGet(&#39;/api&#39;);\n\n// do something\n\np.then(onSuccess , onError);\n\n// do something\n\np.then(onSuccess , onError);</code></pre>\n\n<p>请问，第二个<code>then</code>是否正常执行 ？</p>\n\n<h4>Promise  下的状态</h4>\n\n<p> <code>Promise </code> 定义了其内部的几个状态</p>\n\n<ul><li>pending</li><li>resolved (fullfilled)</li><li>rejected </li></ul>\n\n<p><code>Promise </code> 初始化后 内部状态为 <code>pending</code> ，然后开始执行异步操作，\n当异步操作完成，内部状态转换为 <code>resolved</code> 或 <code>rejected</code> (失败时)。</p>\n\n<p>一旦状态改变，就会被固化，不会再改变。</p>\n\n<p>所以就很好解释，一个状态已经确定的 <code>Promise </code> ,无论你调动多少次<code>then</code>，它都会返回正确且唯一的结果，因为 <code>Promise </code>的结果，是完全依赖它自己的内部状态。</p>\n\n<h4>这个时候我们有必要说一下<code>then</code> 方法到底做了什么？</h4>\n\n<p>不去深入探究的话，你大概会认为<code>then</code>只是注册了一系列回调函数。</p>\n\n<p>其实 <code>then</code> 除了注册回调函数，还会检查 <code>Promise </code> 状态，只要不是<code>pending</code>状态，就回调用相应状态的回调。</p>\n\n<p>同样的，当状态改变的时候，也会检查对应状态是否有已经绑定的回调函数，再按照<code>Promise </code>的方式去执行回调。</p>\n\n<p>正因为这种机制，才能真正实现了<code>Promise </code>的异步操作与回调声明分离，并且通过维护状态变化，更好地控制异步操作结果中的不同情况。</p>\n\n<blockquote><p>注：为了降低理解成本，本文的实现里一个状态默认只处理一个回调函数</p></blockquote>\n\n<h3>一字长蛇阵</h3>\n\n<p>以上便是一个独立的 <code>Promise</code> 的运行机理，在这之上灵活运用才是<code>Promise</code>的终极玩法。</p>\n\n<p>那么我们经常听到的用 <code>Promise</code> 解决回调地狱，是怎么回事呢？看看最终代码：</p>\n\n<pre><code>loadPic(&#39;/path/of/picture.jpg&#39;)\n  .then(...) //图片压缩\n  .then(...) //生成缩略图\n  .then(...); //存储到指定地方</code></pre>\n\n<p>想想用<code>callback</code>的时候你是怎么写的。</p>\n\n<p>它的原理就是，每个<code>then</code>的 resolved 部分，返回一个新的 <code>Promise</code>，\n这么一来就能继续 <code>then</code> 下去，只要每一个环节都遵守<code>Promise</code>规范，就能将一个回调地狱梳理成<strong>串行</strong>的<strong>链式调用</strong>。</p>\n\n<h4>最后附上两种手写 <code>Promise</code> 的参考</h4>\n\n<blockquote><p>http://www.lanhao.name/article/293</p></blockquote>\n\n<p>(未完)</p>",
  "createdAt": 1467022980,
  "modified": 1513778792
}