{
  "id": "292",
  "title": "[总结] ES6中的变量和作用域",
  "keywords": [
    "ES6",
    "JS",
    "javascript"
  ],
  "content": "<p><a href=\"http://www.w3cplus.com/javascript/variables-and-scoping-in-es6.html?utm_source=tuicool&amp;utm_medium=referral\">原文地址</a></p>\n\n<h3>通过let和const确定块作用域</h3>\n\n<p>使用 <code>let</code> 和 <code>const</code> 创建块作用域，他们声明的变量只存在块内。\n比如下面的示例， <code>let</code> 声明的变量 <code>tmp</code> 只存在于 <code>if</code> 语句块，也只有在 <code>if</code> 语句块内有效。</p>\n\n<pre><code>function func () {\n    if (true) {\n        let tmp = 123;\n    }\n    console.log(tmp); // ReferenceError: tmp is not defined\n}</code></pre>\n\n<p>相比之下，使用 <code>var</code> 声明的变量，在整个函数域内都有效：</p>\n\n<pre><code>function func () {\n    if (true) {\n        var tmp = 123;\n    }\n    console.log(tmp); // 123\n}</code></pre>\n\n<p>块作用域也可以存在于整个函数内:</p>\n\n<pre><code>function func () {\n    let foo = 5;\n    if (...) {\n        let foo = 10;\n        console.log(foo); // 10\n    }\n    console.log(foo); // 5\n}</code></pre>\n\n<h3>const创建不可变的变量（常量）</h3>\n\n<p>let 创建的变量是可变的：</p>\n\n<pre><code>let foo = &quot;abc&quot;;\nfoo = &quot;def&quot;;\nconsole.log(foo); // def</code></pre>\n\n<p>而使用 <code>const</code> 创建的变量是不可变量，其是一个常量：</p>\n\n<pre><code>const foo = &quot;abc&quot;;\nfoo = &quot;def&quot;; // TypeError</code></pre>\n\n<p>注意: <code>const</code> 并不影响一个常数是否可变，如果一个常数是一个对象，那它总是一个引用对象，但仍然可以改变对象的本身（如果它是可变的）。</p>\n\n<pre><code>const obj = {};\nobj.prop = 123;\nconsole.log(obj.prop); // 123\nobj = {}; // TypeError</code></pre>\n\n<p>如果你想让 <code>obj</code> 是一个真正的常数，可以使用 <code>freeze</code> 方法 来冻结其值：</p>\n\n<pre><code>const obj = Object.freeze({});\nobj.prop = 123; // TypeError</code></pre>\n\n<h3>循环体内的 const</h3>\n\n<p>一旦通过 <code>const</code> 创建的变量它就是一个常量，它是不能被改变的。但这也并不意味着你不能重新给其设置一个新值。例如，可以通过一个循环来操作：</p>\n\n<pre><code>function logArgs (...args) {\n    for (let [index, elem] of args.entries()) {\n        const message = index + &#39;. &#39; + elem;\n        console.log(message);\n    }\n}\nlogArgs(&quot;Hello&quot;, &quot;everyon&quot;);</code></pre>\n\n<p>输出的结果</p>\n\n<pre><code>0. Helloe\n1. everyone</code></pre>\n\n<h3>什么应该使用 let ，什么时候应该使用 const</h3>\n\n<p>如果你想改变一个变量保存其原始值，你就不能使用 <code>const</code> 来声明：</p>\n\n<pre><code>const foo = 1;\nfoo++; // TypeError</code></pre>\n\n<p>然而，你可以使用 <code>const</code> 声明变量，来引用可变量的值：</p>\n\n<pre><code>const bar = [];\nbar.push(&quot;abc&quot;); // array是一个可变的</code></pre>\n\n<p>我还在仔细考虑使用什么方式才是最好的方式，但是目前情况使用的都是像前面的示例，因为 <code>bar</code> 变量是可变的。我使用 <code>const</code> 表明变量和值是不可变的：</p>\n\n<pre><code>const EMPTY_ARRAY = Object.freeze([]);</code></pre>\n\n<h3>暂时性死区</h3>\n\n<p>使用 <code>let</code> 或 <code>const</code> 声明的变量有一个所谓的暂时性死区(<code>TDZ</code>)：当进入作用域范围，它就不能接受( get 或 set )访问，直到其被声明。</p>\n\n<p>我们来来看一个有关于 <code>var</code> 变量的生命周期，它没有暂时性死区：</p>\n\n<ul><li>当 <code>var</code> 声明了一个变量，其就有一个存储空间（创建一个所谓的绑定）。变量就初始化了，其默认值为 <code>undefined</code></li><li>当执行的范围到达声明处，变量设置为指定的值（如果有赋值的话），如果变量没有赋值，其值仍然是 <code>undefined</code></li></ul>\n\n<p>通过 <code>let</code> 声明变量存在暂时性死区，这意味着他们的生命周期如下：</p>\n\n<ul><li>当使用 let 创建一个变量，其就有一个块作用域，也具有一个存储空间（也就是创建一个所谓的绑定）。其值仍未初始化变量\n获取或设置一个未初始化的变量，得到一个错误ReferenceError</li><li>当执行范围内到达声明的变量处，如果有赋值的话，变量的初始值为指定的初始化值。如果没有，变量的值仍为 undefined</li></ul>\n\n<p>使用 <code>const</code> 声明的变量工作类似于 <code>let</code> ，但它必须要有一个初始化值，而且不能被改变。</p>\n\n<p>在一个<code>TDZ</code>内，通过 <code>if</code> 语句秋设置或获取一个变量将会报错：</p>\n\n<pre><code>if (true) { // TDZ开始\n    // 未初始化tmp变量\n    tmp = &quot;abc&quot;; // ReferenceError\n    console.log(tmp); // ReferenceError\n    let tmp; // TDZ结束，tmp已初始化，其初始值为undefined\n    console.log(tmp); // undefined\n    tmp = 123;\n    console.log(tmp); // 123\n}</code></pre>\n\n<p>下面的例子演示了死区是时间（基于时间），而不是空间（基于位置）：</p>\n\n<pre><code>if (true) { // 进入新作用域，TDZ开始\n    const func = function () {\n        console.log(myVar); // OK\n    }\n    //在TDZ内访问myVar，会引起ReferenceError错误\n    let myVar = 3; // TDZ结束\n    func (); // 调用外面的TDZ\n}</code></pre>\n\n<h3>typeof和TDZ</h3>\n\n<p>一个变量在难以接近TDZ时，这也意味着你不能使用 <code>typeof</code> :</p>\n\n<pre><code>if (true) {\n    console.log(typeof tmp); // ReferenceError\n    let tmp;\n}</code></pre>\n\n<p>在实践中我不认为这是一个问题，因为你不能有条的通过 <code>let</code> 声明变量范围。相反，你可以使用 <code>var</code> 声明变量，而且可以通过 window 创建一个全局变量：</p>\n\n<pre><code>if (typeof myVarVariable === &#39;undefined&#39;) {\n    // `myVarVariable` does not exist =&gt; create it\n    window.myVarVariable = &#39;abc&#39;;\n}</code></pre>\n\n<h3>循环头中的 <code>let</code></h3>\n\n<p>在循环中，你可以通过 <code>let</code> 声明变量，为每次迭代重新绑定变量。比如在 <code>for</code> 、 <code>for-in</code> 和 <code>for-of</code> 循环中。</p>\n\n<p>看起来像下面：</p>\n\n<pre><code>let arr = [];\nfor (let i = 0; i &lt; 3; i++) {\n    arr.push(() = &gt; i);\n}\nconsole.log(arr.map(x =&gt; x())); // [0,1,2]</code></pre>\n\n<p>相比之下，使用 <code>var</code> 声明的变量将在整个循环中都可以工作：</p>\n\n<pre><code>let arr = [];\nfor (var i = 0; i &lt; 3; i++) {\n    arr.push(() =&gt; i);\n}\nconsole.log(arr.map(x =&gt; x())); // [3,3,3]</code></pre>\n\n<p>每次迭代得到一个新的绑定似乎有些奇怪，但当你使用循环创建功能（比如回调事件处理），它显得就非常有用。</p>\n\n<h2>参数</h2>\n\n<h3>参数和局部变量</h3>\n\n<p>如果使用 <code>let</code> 声明变量，它有一个相同的名称，称作参数。静态加载会出错：</p>\n\n<pre><code>function func (arg) {\n    let arg; // Uncaught SyntaxError: Identifier &#39;arg&#39; has already been declared\n}</code></pre>\n\n<p>同样的，将其放在一个作用块里：</p>\n\n<pre><code>function func (arg) {\n    {\n        let arg; // undefined\n    }\n}    </code></pre>\n\n<p>相比之下，使用 <code>var</code> 声明一个和参数相同变量，其作用范围在同一个范围内：</p>\n\n<pre><code>function func (arg) {\n    var arg;\n}</code></pre>\n\n<p>或者</p>\n\n<pre><code>function func (arg) {\n    {\n        var arg;\n    }\n}</code></pre>\n\n<h3>参数默认值和<code>TDZ</code></h3>\n\n<p>如果 参数有默认值 ，他们会当作一系列的 <code>let</code> 语句，而且存在<code>TDZ</code>。</p>\n\n<pre><code>// OK: `y` accesses `x` after it has been declared\nfunction foo(x=1, y=x) {\n    return [x, y];\n}\nfoo(); // [1,1]\n\n// Exception: `x` tries to access `y` within TDZ\nfunction bar(x=y, y=2) {\n    return [x, y];\n}\nbar(); // ReferenceError</code></pre>\n\n<h3>默认参数不知道其自身的范围</h3>\n\n<p>参数默认值的范围是独立于其自身范围。这意味着内部定义的方法或函数参数的默认值不知道其内部的局部变量：</p>\n\n<pre><code>let foo = &#39;outer&#39;;\nfunction bar(func = x =&gt; foo) {\n    let foo = &#39;inner&#39;;\n    console.log(func()); // outer\n}\nbar();</code></pre>\n\n<h3>全局对象</h3>\n\n<p>JavaScript全局对象（浏览器中的window，Node.js中的global）存在的问题比他的特性多，尤其是性能。这也是为什么ES6中不引用的原因。</p>\n\n<p>全局对象的属性都是全局变量，在全局作用域下都有效，可以通过 <code>var</code> 或 <code>function</code> 方式声明。</p>\n\n<p>但现在全局变量也不是全局对象。在全局作用域下，可以通过 <code>let</code> 、 <code>const</code> 或者 <code>class</code> 声明。</p>\n\n<h3>函数声明和class声明</h3>\n\n<p>function 声明：</p>\n\n<ul><li>像 let 一样，声明的是一个块作用域</li><li>像 var 一样，在全局对象创建属性(全局作用域)</li><li>存在生命提升：独立于一个函数声明中提到它的范围，它总是存在于开始时创建的范围内</li></ul>\n\n<p>下面的代码演示了函数声明的提升：</p>\n\n<pre><code>{ // Enter a new scope\n\n    console.log(foo()); // OK, due to hoisting\n    function foo() {\n        return &#39;hello&#39;;\n    }\n}</code></pre>\n\n<h4>类声明：</h4>\n\n<ul><li>是一个块作用域</li><li>不能在全局对象上创建属性</li><li>不存在生命提升</li></ul>\n\n<p><code>class</code> 不存在生命提升可能令人惊讶，那是因为其存在于引擎下，而不是一个函数。这种行为的理由是，他们扩展表达式。这些表达式在适当的时间内被执行。</p>\n\n<pre><code>{ // Enter a new scope\n\n    const identity = x =&gt; x;\n\n    // Here we are in the temporal dead zone of `MyClass`\n    let inst = new MyClass(); // ReferenceError\n\n    // Note the expression in the `extends` clause\n    class MyClass extends identity(Object) {\n    }\n}</code></pre>",
  "createdAt": 1466590020,
  "modified": 1466592711
}