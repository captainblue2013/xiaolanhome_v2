{
  "id": 320,
  "title": "使用channel来做并发控制",
  "keywords": [
    "go",
    "golang",
    "channel"
  ],
  "content": "<h4>0x00 还是同时拉取两个城市天气的问题</h4>\n\n<blockquote><p>题目具体请参考上一篇 《<a href=\"http://lanhao.name/article/319\">使用 WaitGroup 做并发控制</a>》</p></blockquote>\n\n<h4>0x01 这次我们直奔代码</h4>\n\n<blockquote><p>此处只展示结构，完整代码请看 <a href=\"https://github.com/captainblue2013/pieces-of-code\">这里</a></p></blockquote>\n\n<pre><code>package main\n\nimport (\n\t&quot;encoding/json&quot;\n\t&quot;fmt&quot;\n\t&quot;io/ioutil&quot;\n\t&quot;net/http&quot;\n)\n\ntype WeatherBody struct {\n\tWeatherInfo `json:&quot;weatherinfo&quot;`\n}\n\ntype WeatherInfo struct {\n\t// 城市\n\tCity string `json:&quot;city&quot;`\n\t// 最低温度\n\tLow string `json:&quot;temp1&quot;`\n\t// 最高温度\n\tHigh string `json:&quot;temp2&quot;`\n}\n\n// 获取天气情况的函数\nfunc GetWeatherByCity(cityCode string) WeatherInfo {\n\tresp, err := http.Get(&quot;http://www.weather.com.cn/data/cityinfo/&quot; + cityCode + &quot;.html&quot;)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(resp.Body)\n\tweatherBody := WeatherBody{}\n\n\tjson.Unmarshal(body, &amp;weatherBody)\n\n\treturn weatherBody.WeatherInfo\n}\n\nfunc main() {\n\t// 待宰的羔羊\n\tcityIDS := []string{&quot;101010100&quot;, &quot;101270101&quot;}\n\tresult := []WeatherInfo{}\n\t// 记录任务完成的计数器\n\ttaskCount := 0\n\t// 创建一个channal, 用了接受完成信号\n\ttaskChan := make(chan bool)\n\tfor _, cityID := range cityIDS {\n\t\t// 此处是不是很熟悉？\n\t\tid := cityID\n\t\tgo func(ch chan bool) {\n\t\t\tweatherInfo := GetWeatherByCity(id)\n\t\t\tresult = append(result, weatherInfo)\n\t\t\t// 当任务完成，向channel内发送一个信号\n\t\t\ttaskChan &lt;- true\n\t\t}(taskChan)\n\t}\n\n\tfor {\n\t\t// 在死循环种，这一步会阻塞，直到从channel中接收到数据\n\t\t&lt;-taskChan\n\t\t// 每次收到信号，计数器加一，直到计数器等于任务个数，跳出循环\n\t\ttaskCount++\n\t\tif taskCount == len(cityIDS) {\n\t\t\t// 全部完成\n\t\t\tfmt.Printf(&quot;%+v\\n&quot;, result)\n\t\t\tbreak\n\t\t}\n\t}\n}</code></pre>\n\n<h5>主要代码讲解</h5>\n\n<ol><li>通过计数器<code>taskCount</code>来记录完成任务的个数</li><li>通过<strong>channel</strong>  <code>taskChan</code>来进行主线与支线的通信</li><li>在一个死循环里<strong>阻塞</strong>代码，直到计数器值满足要求，跳出循环</li><li>打印结果</li></ol>\n\n<h4>0x10 提问 &amp; 练手 环节</h4>\n\n<ol><li><p>改动上述代码，实现功能：</p><blockquote><p>只把最先完成的任务结果打印出来</p></blockquote></li><li><p>进阶：尝试不使用 <code>result</code> 这个变量，实现题目功能</p></li></ol>",
  "createdAt": 1559573554,
  "modified": 1559573554
}